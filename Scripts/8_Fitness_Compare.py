#!/usr/bin/python3
import numpy as np
import pandas as pd
import sys, os
import matplotlib.pyplot as plt
import scipy as sp
from scipy.stats import ttest_ind

# This will take two different .Statistics.csv files generated from the 7_Replicates_Table.py function as input and trim the rows to contain the same list of 
# 	analyzed genes and generate a new file with the individual fitness and mean values for each condition that is compared. This enables the ability to plot the 
#	two fitness score means for each gene against eachother as a scatterplot. The trimmed genes are listed in the <Condition_1>_v_<Condition_2>_trimmed_genes.csv
#	output file.
#	
# Note, the the same baseline (T=0) condition must be used for comparing different enrichment conditions to eachother.
# 
# 	A two-tailed two-sample t test is used to test whether the mean fitness values between conditions are significantly different from eachother
#		The t statistic and p-value for each gene are provided <Condition_1>_v_<Condition_2>_Summary.csv output file.
#	The p-values are adjusted for multiple testing according to the positive false discovery method from Benjamini & Hochberg, 1995 and Storey JD, 2003,
#		yielding q-values. The q-values were adjusted for monotonicity according to the method described by Yekutieli and Benjamini, 1999 
#		(https://www.sciencedirect.com/science/article/pii/S0378375899000415?via%3Dihub) and these values, along with the individual and mean fitness scores,
#		t statistic, p-value, and un-adjusted q-values are provided in the ‘_Summary.csv’ output file.  

# Usage: 
#	PATH/8_Fitness_Compare.py <PATH/Condition_1_Fitness_Summary.csv> <'Condition_1_Label’> <PATH/Condition_2_Fitness_Summary.csv> <'Condition_2_Label’> 
#
#
#  Input Files:
#		<PATH/Condition_1_Fitness_Summary.csv> Fitness summary file for the first enrichment condition, as generated by the 7_Replicates_Table.py function
#		<PATH/Condition_2_Fitness_Summary.csv> Fitness summary file for the second enrichment condition, as generated by the 7_Replicates_Table.py function
#		
#
#
#  Output files:
#		<Condition_1>_v_<Condition_2>_trimmed_genes.csv is a csv file with a list of all the unused genes (not found in both _Fitness_Summary.csv files
#			being compared) in the analysis. The enrichment condition title is abstracted from the input condition labels.
#		<Condition_1>_v_<Condition_2>_Summary.csv is a csv file with a list of all the merged gene fitness data along with the mean fitness calculated
#			for each gene between the three replicates for each condition. Additionally, the t-score and p-value from a two-tailed two sample t-test is provided.
#			The positive FDR (pFDR) correction for multiple testing was used to determine corresponding q-values and this column was added to the table.
#			Finally a column where the q-values were adjusted for monotonicity according to the method described by Yekutieli and Benjamini, 1999 is provided. 

# sysnames
Condition_1 = sys.argv[1]
Cond1Label = sys.argv[2]
Condition_2 = sys.argv[3]
Cond2Label = sys.argv[4]


#first get the current working directory
cwd = os.getcwd()

# load each .csv files with pandas, reading all rows 
# migrate data into a numpy array, calling labels and making an array of all genes (locus ID) in each file 
CondA = pd.read_csv(Condition_1)
CondB = pd.read_csv(Condition_2)

#Navigate back to the current directory 
os.chdir(cwd)

CondA = np.array(CondA[:], dtype=str)
CondAGenes = CondA[1:,0]

CondB = np.array(CondB[:], dtype=str)
CondBGenes = CondB[1:,0]  

#create a set for each gene list
setA =set(CondAGenes)
setB =set(CondBGenes)

rmA = list(setA-setB)
rmB = list(setB-setA)

remove = np.append(rmA,rmB)

#read through each gene list and if it does not exist in the other gene list, delete that row from the  numpy array
NewCondA =[]
removeA =[]
for i in range(0,len(CondAGenes)):
	j=i+1
	if CondAGenes[i] in remove: removeA.append([j])

NewCondA = np.delete(CondA, removeA, 0)


NewCondB =[]
removeB =[]
for i in range(0,len(CondBGenes)):
	j=i+1
	if CondBGenes[i] in remove: removeB.append([j])

NewCondB = np.delete(CondB, removeB, 0)


#Make new set from NewCod arrays and use them to call which genes were deleted from analysis 
NewCondAGenes = NewCondA[:,0]
NewCondBGenes = NewCondB[:,0]


GenesRemovedA = []
GenesRemovedA=list(set(CondAGenes) - set(NewCondAGenes))

GenesRemovedB = []
GenesRemovedB=list(set(CondBGenes) - set(NewCondBGenes))

#merge the genes removed lists into one list
GenesRemoved = []
GenesRemoved = np.append(GenesRemovedA,GenesRemovedB)

#Generate a csv file with a summary of genes that were deleted from each replicate call trimmed_genes.csv
#first, come up with a unique identifier for each index set

#Full_Table = np.concatenate((NewCondA , NewCondB[0:, 1:]), 1)

np.savetxt((Cond1Label+'_v_'+Cond2Label+'_trimmed_genes.csv'), GenesRemoved, delimiter=',', fmt='%s')

#Perform a two-sided two sample t-test comparing the two conditions to identify significantly different normalized fitness values
FitValsA = np.array(NewCondA[0:,1:4], dtype=float)
FitValsB = np.array(NewCondB[0:,1:4], dtype=float)

tscore = []
tscoreArray = []
pvalue = []
pvalueArray = []
for i in range(0,len(FitValsA)):
	tscore, pvalue = sp.stats.ttest_ind(FitValsA[i,:], FitValsB[i,:], equal_var=True, alternative='two-sided')
	pvalue = f"{pvalue:.11f}"
	tscoreArray = np.append(tscoreArray,tscore)
	pvalueArray = np.append(pvalueArray,pvalue)

Stats = np.column_stack((tscoreArray, pvalueArray))

Full_Table = np.concatenate((NewCondA , NewCondB[0:, 1:], Stats), 1)

#Sort the table by p-value 
ind=np.argsort(Full_Table[:,-1])
sort_Full_Table = Full_Table[ind]

#Obtain the q-value according to the Benjamini-Hochberg method: q(i)=p(i)*N/i
sorted_pVals = np.array(sort_Full_Table[:,10], dtype=float)
q = []
qVals = []
N=len(sorted_pVals)
for i in range(1,N+1):
	p = sorted_pVals[i-1]
	q=p*N/i
	if q>1: q=1
	qVals=np.append(qVals,q)

#Importantly, the last step involves replacing q(i) with the lowest value among all lower-rank Q-values that were calculated.  
# This is because q(i) is not a monotonic function, so moving to a lower p-value might actually result in a higher Q-value, which doesn't make sense. 
# This adjustment ensures monotonically decreasing Q-values as explained: 

# https://riffyn.com/blog/false-discovery-rate or
# https://brainder.org/2011/09/05/fdr-corrected-fdr-adjusted-p-values/

# Published in Yekutieli and Benjamini, 1999: https://www.sciencedirect.com/science/article/pii/S0378375899000415?via%3Dihub

# This process involves finding the minimum q value that follows the current q value and adjusting the value accordingly
# such that q*(i)=q(k), k >/= i, where q(k) =  p(k)*N/k

#Make a new array called sort_qVal
sort_qVal=[None]*len(qVals)

for i in range(0,len(qVals)):
	sort_qVal[i] =qVals[i]

#Iterate through the qVal array and replace an element with the minimum value that follows it, if one exists 
minVal = []
for i in range(0,len(qVals)):
    minVal = min(qVals[i:])
    if minVal < sort_qVal[i]:
    	sort_qVal[i]=minVal

Col_qVals = np.column_stack((qVals, sort_qVal))

Stats_Full_Table = np.append(sort_Full_Table, Col_qVals, axis=1)

#Generate a csv file with the normalize fitness scores and means from both conditions called Cond1vCond2_Cond1_table.csv
s='_'
Cond1A = s.join([Cond1Label,'RepA']) 
Cond1B = s.join([Cond1Label,'RepB'])
Cond1C = s.join([Cond1Label,'RepC'])
Cond1mean = s.join([Cond1Label,'mean'])

Cond2A = s.join([Cond2Label,'RepA']) 
Cond2B = s.join([Cond2Label,'RepB'])
Cond2C = s.join([Cond2Label,'RepC'])
Cond2mean = s.join([Cond2Label,'mean'])

headlist = ['Locus_Tag',Cond1A,Cond1B,Cond1C,Cond1mean,Cond2A,Cond2B,Cond2C,Cond2mean,'t-statistic', 'p-value','q-value', 'adjusted_q-value']

s=','
head = s.join(headlist)

np.savetxt((Cond1Label+'_v_'+Cond2Label+'_Summary.csv'), Stats_Full_Table, delimiter=',', fmt='%s', header=head)

