#!/usr/bin/python3
import numpy as np
import pandas as pd
import sys, os
from matplotlib import rc, font_manager
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import copy

# Loads the in3genes.csv file generated by the BarSeqProc_loadExps.py function, groups transposon insertions according to gene locus,
#		and eliminates genes that have fewer than thirty total insertion reads in the baseline sample. These genes are then used to calculate fitness
#		values for each gene in condition v. baseline. A normalized gene fitness score and t-like statistic is calculated, according to the methods
#		used in Wetmore, Kelly M., et al. MBio (2015). Modifications are fitness normalization used only the approach described for small gene scaffolds
#		and no gene end count trimming was performed.
#	
# Usage:
# 	python3 PATH/5_BarSeqProc_analyzeExp.py <PATH/1_M9A_in3genes.csv_file> 
#
#
# Input File
#	in3genesFile is the file generated from the 4_BarSeqProc_loadExps.py function made from extracting rows from the counts-in-genes.csv file, where >= 3
#		distinct transposon insertions exist for each gene in T0 baseline condition	
#
#	
# Output files:
#	<baseline_condition>_<30_Unused_BL_genes.csv is a file listing all the genes that DID NOT satisfy the baseline counts > 30 for each gene condition
#	<baseline_condition>_GenesUsedforAnalysis.csv is a file listing all the genes that DID satisfy the baseline counts > 30 for each gene condition
#	<condition_tested>_Unused_0ct_Exp_genes.csv is a file listing all the genes from the _GenesUsedforAnalysis.csv file where there was a 0ct for that
#		gene in the designated condition tested.  This file will not be generated if no genes have a zero count in the condition tested.
#	<condition_tested>_GenesUsedforAnalysis_no_ZeroSums.csv lists all genes from the _GenesUsedforAnalysis.csv file where, for the analyzed condition,
#		1 or more counts were observed in the given gene
#	<condition_tested>_allAnalyzedGenes.csv provides the following data for all genes listed in the _GenesUsedforAnalysis_no_ZeroSums.csv file
#		geneName-old locus tag designation for a gene (PP_xxxx)
#		normGeneFit- the normalized gene fitness of the gene (condition tested vs. baseline condition), as calculated according to Wetmore, Kelly M., et al. MBio (2015)
#		tStat_abs- the t-like statistic, as calculated according to Wetmore, Kelly M., et al. MBio (2015)

if len(sys.argv) < 1:
	print("Run this in the directory where you want your output files.")
	print("Usage: " + sys.argv[0] + " <PATH/in3genes_file> ")
	sys.exit(0)

if not os.path.isfile(sys.argv[1]):
	print (sys.argv[1] + " does not exist... aborting...")
	sys.exit(0)

# sysnames
in3genesFile = sys.argv[1]

#####################################################################################
# load genes file as pandas dataframe and then iterate through each condition using #
# groupby function to merge counts from the same locus across all loci              #
#####################################################################################

Counts_Table = pd.read_csv(in3genesFile, sep=",")

for z in range(7,Counts_Table.shape[1]):
	colname = Counts_Table.columns[z]
	GeneSums= Counts_Table.groupby('locusId',sort=False)[colname].sum()
	if z ==7:
		New_Gene_Sums= GeneSums.to_frame(name = colname)
	if z >7:
		sample_averages = GeneSums.to_frame(name = colname)
		New_Gene_Sums= New_Gene_Sums.join(sample_averages)

# ID genes that have <30 reads per gene in Time0 and generate a <30_Unused_BL_genes.csv file
BL_column_name = New_Gene_Sums.columns[0]
genes_less_30 = pd.DataFrame(New_Gene_Sums.loc[New_Gene_Sums[BL_column_name] < 30])
genes_less_30.to_csv((BL_column_name+'_<30_Unused_BL_genes.csv'), index=True, header=True)

# Delete rows where Baseline genes have <30 reads from the master dataframe and save this as a GenesUsedforAnalysis.csv file
dropped_gene_labels = list(genes_less_30.index)
NoLess30_Gene_Sums_Table = New_Gene_Sums.drop(dropped_gene_labels)
NoLess30_Gene_Sums_Table.to_csv((BL_column_name+'_GenesUsedforAnalysis.csv'), index=True, header=True)

#####################################################################################
##### Now perform fitness calcs for each enrichment condition and baseline pair #####
#####################################################################################   
   
# Iterate through each condition to baseline pair and abstract out the count values into arrays
for i in range(1,NoLess30_Gene_Sums_Table.shape[1]):
	print('\nStarting Analysis of Set', i)
	BL_Sums=NoLess30_Gene_Sums_Table.loc[:,NoLess30_Gene_Sums_Table.columns[0]].values
	strain_Sums=NoLess30_Gene_Sums_Table.loc[:,NoLess30_Gene_Sums_Table.columns[i]].values
	Loci_Labels=NoLess30_Gene_Sums_Table.index

	remove2 = []  # eliminate genes if strainSums = 0
	Genes_Removed = []
	for j in range(0,len(strain_Sums)):
		if strain_Sums[j] == 0: 
			remove2.append([j])
			Genes_Removed = np.append(Genes_Removed,Loci_Labels[j])
	if remove2:
		print('\n',len(remove2),' additional genes contain zero reads in the '+NoLess30_Gene_Sums_Table.columns[i]+' pool and will be removed.')
		print("\n Deleted genes include: ",Genes_Removed,'\n')
		np.savetxt((NoLess30_Gene_Sums_Table.columns[i]+'_Unused_0ct_Exp_genes.csv'), Genes_Removed, delimiter=',', fmt='%s')
		BL_Sums = np.delete(BL_Sums, remove2)
		strain_Sums = np.delete(strain_Sums, remove2)
		Loci_Labels = np.delete(Loci_Labels, remove2)
	np.savetxt((NoLess30_Gene_Sums_Table.columns[i]+'_GenesUsedforAnalysis_noZeroSums.csv'), Loci_Labels, delimiter=',', fmt='%s')

	#Use the New 'No <30 count Loci_Labels' to abstract out strain counts (prior to being grouped) for all genes used in the analysis for the current comparisson
	Used_Gene_Table_Counts = Counts_Table[Counts_Table['locusId'].isin(Loci_Labels)]
	Used_Strain_Counts_BL=Used_Gene_Table_Counts.loc[:,Used_Gene_Table_Counts.columns[7]].values
	Used_Strain_Counts_Enrichment=Used_Gene_Table_Counts.loc[:,Used_Gene_Table_Counts.columns[i+7]].values
	Used_Genes=list(Used_Gene_Table_Counts.loc[:,Used_Gene_Table_Counts.columns[5]])
	Gene_Positions =np.array(Used_Gene_Table_Counts.loc[:,Used_Gene_Table_Counts.columns[6]].values)

	# perform preliminary strain fitness (psf) and preliminary gene fitness (pgf) calculations and use median pgf for each gene to determine their corresponding pseudocount values
	readRatio = strain_Sums/BL_Sums
	prelimStrainF = np.zeros(shape=(len(Used_Strain_Counts_BL)))
	prelimGeneF = np.zeros(shape=(len(Loci_Labels)))
	psi = np.zeros(shape=(len(Loci_Labels)))
	loci_counter = 0
	Gene_psf_list = []
	strain_number = []

	for k in range(0,len(Used_Strain_Counts_BL)):
		if Used_Genes[k] != Loci_Labels[loci_counter]: #The counter is a method for ensuring the strains in the same gene are grouped, once the full genes psfs have been calculated the median is calculated and stored
			pgf = np.median(Gene_psf_list)
			prelimGeneF[loci_counter] = pgf
			strain_number = len(Gene_psf_list)
			# determine strain pseudocount values to use for each strain (psi in Wetmore et al. calcs), once the pgf is calculated
			if strain_number >= 3:
				psi1 = (2**pgf)*readRatio[loci_counter] # psi = (2^prelimGeneF)*readRatio for genes with >=3 strains. 
			else:
				psi1 = readRatio[loci_counter] 	# otherwise, psi = readRatio avoids noise in low-count estimates
			psi[loci_counter] = psi1
			Gene_psf_list = []
			strain_number = []
			loci_counter = loci_counter + 1
		ratio_val = readRatio[loci_counter]
		psf = np.log2(Used_Strain_Counts_Enrichment[k] + np.sqrt(ratio_val)) - np.log2(Used_Strain_Counts_BL[k] + 1/(np.sqrt(ratio_val)))
		prelimStrainF[k] = psf
		Gene_psf_list.append(psf)
		if k == len(Used_Strain_Counts_BL)-1: #This finishes the pseudocount calculation once the last strain's psf is calculated
			pgf = np.median(Gene_psf_list)
			prelimGeneF[loci_counter] = pgf
			strain_number = len(Gene_psf_list)
			if strain_number >= 3:
				psi1 = (2**pgf)*readRatio[loci_counter] 
			else:
				psi1 = readRatio[loci_counter] 
			psi[loci_counter] = psi1

	# Now that pseudocount values for each gene are known, determine actual strain fitness and use to calculate weighted variance and unnormalized gene fitness 
	loci_counter = 0
	strainPseudoCount = []
	BL_PseudoCount =[]
	geneSet_strainFitness = []
	All_strain_Fitness = np.zeros(shape=(len(Used_Strain_Counts_BL)))
	geneSet_strainVar = []
	maxWt = 5.044 #= ((2/21)/((np.log(2))**2))**(-1)     # strains with low variance are favored, but not too much 
	geneSet_strainWt = []
	All_stain_Weight = np.zeros(shape=(len(Used_Strain_Counts_BL)))
	uGeneFitness = np.zeros(shape=(len(Loci_Labels)))
	num = []
	denom = []
		
	for k in range(0,len(Used_Strain_Counts_BL)):
		if Used_Genes[k] != Loci_Labels[loci_counter]: 
			# calculate unnormalized gene fitness (uGeneFitness) before moving on to the next gene
			for d in range(0,len(geneSet_strainFitness)):
				m1 = geneSet_strainWt[d]*geneSet_strainFitness[d]
				m2 = geneSet_strainWt[d]
				num.append(m1)
				denom.append(m2)
			uGeneFitness1 = sum(num)/sum(denom)
			uGeneFitness[loci_counter] = uGeneFitness1
			num = [] #reset to empty after use
			denom = []  #reset to empty after use
			geneSet_strainFitness = [] #reset to empty after use
			geneSet_strainVar = [] #reset to empty after use
			geneSet_strainWt = [] #reset to empty after use
			loci_counter = loci_counter + 1 #This moves the gene-associated pseudocount to the correct gene

		gene_pseudocount = psi[loci_counter]	
		strainPseudoCount = np.sqrt(gene_pseudocount)
		BL_PseudoCount = 1/np.sqrt(gene_pseudocount)
		#determine strain fitness using gene pseudocount values
		sf = np.log2(strainPseudoCount + Used_Strain_Counts_Enrichment[k]) - np.log2(BL_PseudoCount + Used_Strain_Counts_BL[k])
		geneSet_strainFitness.append(sf)
		All_strain_Fitness [k] = sf
		# calculate strain variance, use it to weight gene fitness calc's (weight inversely prop. to strain variance)
		sv = ((1/(1+Used_Strain_Counts_Enrichment[k])) + (1/(1+Used_Strain_Counts_BL[k])))/((np.log(2))**2)               # naive strain variance
		geneSet_strainVar.append(sv)
		# calculate the weighted strain variance
		sw1 = min(maxWt, (1/(sv)))
		geneSet_strainWt.append(sw1)
		All_stain_Weight [k] = sw1

		if k == len(Used_Strain_Counts_BL)-1: #This finishes the pseudocount calculation once the last strain's psf is calculated
			for f in range(0,len(geneSet_strainFitness)):
				m1 = geneSet_strainWt[f]*geneSet_strainFitness[f]
				m2 = geneSet_strainWt[f]
				num = np.append(num, [m1])
				denom = np.append(denom, [m2])
			uGeneFitness1 = sum(num)/sum(denom)
			uGeneFitness[loci_counter] = uGeneFitness1

			
	##################################
	##### normalize gene fitness #####
	##################################

	# normalize gene fitness using median of 251-gene window (125 genes on either side of GOI)
	normGeneFitness = np.zeros(shape=(len(uGeneFitness)))
	gene_window = []
	for l in range(0,len(uGeneFitness)):
		m = l-125
		n = l+126 #need to count the gene in question and 125 to the right
		if m < 0: 
			m_new = len(uGeneFitness) + m
			m_new1 = uGeneFitness[m_new:]
			m_new2 = uGeneFitness[0:l]
			m_window = np.concatenate([m_new1,m_new2], dtype=float)
			n_window = uGeneFitness[l:n]
			gene_window = np.concatenate([m_window,n_window], dtype=float)
		if n >= len(uGeneFitness): 
			n_new = n - len(uGeneFitness)
			n_new1 = uGeneFitness[0:n_new]
			n_new2 = uGeneFitness[l:]
			m_window = uGeneFitness[m:l]
			n_window = np.concatenate([n_new1,n_new2], dtype=float)
			gene_window = np.concatenate([n_window,m_window], dtype=float)
		if m >= 0 and n < len(uGeneFitness): 
			m_window = uGeneFitness[m:l]
			n_window = uGeneFitness[l:n]
			gene_window = np.concatenate([m_window,n_window], dtype=float)
		nGF = uGeneFitness[l] - np.median(gene_window)
		normGeneFitness[l] = nGF
		gene_window = []

	##################################################################
	##################################################################
	##################################################################
	#####              							                 #####
	#####             CALCULATE T-LIKE STATISTICS                #####
	#####              							                 #####
	##################################################################
	##################################################################
	##################################################################

	###########################################################################################
	# calculate sumSq, the weighted sum of squared differences of strain fitness for the gene #
	###########################################################################################

	sumSq = np.zeros(shape=(len(Loci_Labels)))
	number_unique_strains_at_locus =[]           
	geneSet_SumSq = []
	geneSet_strainWt = []
	geneSet_strainFitness = []
	strain_Fitness_1 = []
	strain_Weight_1 = []
	strain_Fitness_2 = []
	strain_Weight_2 = []
	strain_1_BL_count = 0
	strain_2_BL_count = 0
	strain_1_Enrichment_count = 0
	strain_2_Enrichment_count = 0
	uGF1 = []
	uGF2 = []
	Enrichment_sums_halves =np.zeros(shape=(len(Loci_Labels)))   
	BL_sums_halves = np.zeros(shape=(len(Loci_Labels)))
	loci_counter = 0
	for u in range(0,len(Used_Genes)):
		if Used_Genes[u] != Loci_Labels[loci_counter]: 
			# calculate sumSq for each gene before moving on to the next gene
			numSS = []
			denomSS = []
			for n in range(0,len(geneSet_strainWt)):
				mm1 = geneSet_strainWt[n]*((geneSet_strainFitness[n]-uGeneFitness[loci_counter])**2)
				mm2 = geneSet_strainWt[n]
				numSS.append(mm1)
				denomSS.append(mm2)
			number_unique_strains_at_locus.append(len(geneSet_strainWt))
			sumSq1 = sum(numSS)/sum(denomSS)
			sumSq[loci_counter] = sumSq1
			geneSet_strainWt = []
			geneSet_strainFitness = []
			# calculate uGF1 and uGF2, unnormalized gene fitness values for each gene half, if the T=0 reads count >= 15, before moving on to the next gene
			if strain_1_BL_count > 14 and strain_2_BL_count >14:
			#if len(strain_Fitness_1) > 0 and len(strain_Fitness_2) > 0:
				num_FirstHalf = []
				denom_FirstHalf = []
				num_SecondHalf = []
				denom_SecondHalf = []
				for w in range(0,len(strain_Fitness_1)):
					num_FirstHalf.append(strain_Weight_1[w]*strain_Fitness_1[w]) #First half strains
					denom_FirstHalf.append(strain_Weight_1[w])
				for y in range(0,len(strain_Fitness_2)):
					num_SecondHalf.append(strain_Weight_2[y]*strain_Fitness_2[y]) #Second half strains
					denom_SecondHalf.append(strain_Weight_2[y])
				uGF1.append(sum(num_FirstHalf)/sum(denom_FirstHalf))
				uGF2.append(sum(num_SecondHalf)/sum(denom_SecondHalf))
				Enrichment_sums_halves1 = strain_1_Enrichment_count + strain_2_Enrichment_count      		# get count sums for just the genes used to estimate Vt
				Enrichment_sums_halves[loci_counter] = Enrichment_sums_halves1
				BL_sums_halves1 =  strain_1_BL_count + strain_2_BL_count 
				BL_sums_halves[loci_counter] = BL_sums_halves1
 			#reset values
			strain_Fitness_1 = []
			strain_Weight_1 = []
			strain_Fitness_2 = []
			strain_Weight_2 = []
			strain_1_BL_count = 0
			strain_2_BL_count = 0
			strain_1_Enrichment_count = 0
			strain_2_Enrichment_count = 0
			loci_counter = loci_counter + 1 #This moves the gene-associated pseudocount to the correct gene
		#Need to call back stored strain weight and strain fitness values from previous calculation above
		geneSet_strainWt.append(All_stain_Weight[u])
		geneSet_strainFitness.append(All_strain_Fitness[u])
		# Sort strain fitness and strain weights into two lists/each, based on position in gene (1st or 2nd half), this will be used below
		# Note, unlike the Wetmore et al., 2015 manuscript, strain counts from transposon insertions in the first or last 10% of the gene are still included
		# 		from a genetic point of view, if a transposon is inserted in the first 10% of gene there are only rare instances where that is not polar for 
		# 		disruption of gene (both by way of amino acid changes and by way of native promoter to CDS uncoupling)
		# Also Baseline (T=0) strain counts and Enrichment strain counts are gathered, since if either gene half doesn't have a BL count >15 or if the enrichment count !> 0, the gene is excluded from the analysis
		gene_position = Gene_Positions[u]
		if gene_position <= 0.5:
			strain_Weight_1.append(All_stain_Weight[u])
			strain_Fitness_1.append(All_strain_Fitness[u])
			strain_1_BL_count += Used_Strain_Counts_BL[u]
			strain_1_Enrichment_count += Used_Strain_Counts_Enrichment[u]
		if gene_position > 0.5:
			strain_Weight_2.append(All_stain_Weight[u])
			strain_Fitness_2.append(All_strain_Fitness[u])
			strain_2_BL_count += Used_Strain_Counts_BL[u]
			strain_2_Enrichment_count += Used_Strain_Counts_Enrichment[u]

		#This finishes the above sumSq and uGF1/uGF2 calculations once the data they depend upon from the last strain is calculated
		if u == len(Used_Genes)-1: 
			numSS = []
			denomSS = []
			for n in range(0,len(geneSet_strainWt)):
				mm1 = geneSet_strainWt[n]*((geneSet_strainFitness[n]-uGeneFitness[loci_counter])**2)
				mm2 = geneSet_strainWt[n]
				numSS.append(mm1)
				denomSS.append(mm2)
			number_unique_strains_at_locus.append(len(geneSet_strainWt))
			sumSq1 = sum(numSS)/sum(denomSS)
			sumSq[loci_counter] = sumSq1
			geneSet_strainWt = []
			geneSet_strainFitness = []
			# calculate uGF1 and uGF2, unnormalized gene fitness values for each gene half, if the T=0 reads count >= 15, before moving on to the next gene
			if strain_1_BL_count > 14 and strain_2_BL_count >14:
			#if len(strain_Fitness_1) > 0 and len(strain_Fitness_2) > 0:
				num_FirstHalf = []
				denom_FirstHalf = []
				num_SecondHalf = []
				denom_SecondHalf = []
				for w in range(0,len(strain_Fitness_1)):
					num_FirstHalf.append(strain_Weight_1[w]*strain_Fitness_1[w]) #First half strains
					denom_FirstHalf.append(strain_Weight_1[w])
				for y in range(0,len(strain_Fitness_2)):
					num_SecondHalf.append(strain_Weight_2[y]*strain_Fitness_2[y]) #Second half strains
					denom_SecondHalf.append(strain_Weight_2[y])
				uGF1.append(sum(num_FirstHalf)/sum(denom_FirstHalf))
				uGF2.append(sum(num_SecondHalf)/sum(denom_SecondHalf))
				Enrichment_sums_halves1 = strain_1_Enrichment_count + strain_2_Enrichment_count      		# get count sums for just the genes used to estimate Vt
				Enrichment_sums_halves[loci_counter] = Enrichment_sums_halves1
				BL_sums_halves1 = strain_1_BL_count + strain_2_BL_count 
				BL_sums_halves[loci_counter] = BL_sums_halves1
	
	 #eliminates the 0's automatically generated when creating these numpy arrays above
	Enrichment_sums_halves = Enrichment_sums_halves[Enrichment_sums_halves != 0]
	BL_sums_halves = BL_sums_halves[BL_sums_halves != 0]

	#Calculate Vn, the naive variance and the median is over genes used to estimate Vt (uGF1,2)
	Vn = np.zeros(shape=(len(strain_Sums)))
	for u in range(0,len(strain_Sums)):
		naiveGeneVariance = ((1/(1+strain_Sums[u])) + (1/(1+BL_Sums[u])))/((np.log(2))**2)  # naive gene variance
		Vn[u] = naiveGeneVariance

	# Calculate typical gene variance (Vt), variance in the typical gene, based on median absolute difference between the two halves
	# Also, in the same loop calculate Vn for just the genes used to estimate Vt -- the halfs (VnH)
	madsdiff = np.zeros(shape=(len(uGF1)))
	VnH = [] 					
	for q in range(0,len(uGF1)):
		madsdiff1 = np.absolute(uGF1[q] - uGF2[q])
		madsdiff[q] = madsdiff1
		# calculate Vn for just the genes used to estimate Vt -- the halfs (VnH)
		naiveGeneVar_halves= ((1/(1+Enrichment_sums_halves[q])) + (1/(1+BL_sums_halves[q])))/((np.log(2))**2)
		VnH.append(naiveGeneVar_halves)
	mad12 = np.median(madsdiff)     							# mad12 is the median absolute difference between half1, half2          	
	qnorm = 0.674                                           	# qnorm(0.75) = 0.674, 75th percentile of normal distribution
	Vt = (mad12**2)/((2*qnorm)**2)          					# variance in typical gene

	# calculate pseudovar (Vg), prior estimate of variance in gene fitness
	# from Wetmore et al., Vg = Vt * [Vn/median(Vn)]^2, where median(Vn) is for just the genes used to estimate Vt
	medVn_halves = np.median(VnH)               				# take median over just the genes used to estimate Vt
	Vg = []                                              # calculate pseudovariance, Vg, for each gene
	for u in range(0,len(Vn)):
		pseudovar = Vt*((Vn[u]/medVn_halves)**2)
		Vg.append(pseudovar)

	# calculate estimated variance for each gene. From Wetmore et al., Ve = (sumSq + Vg) / n , where n is the number of different strains
	Ve = np.zeros(shape=(len(sumSq)))
	for u in range(0,len(sumSq)):
		estGeneVar = (sumSq[u] + Vg[u])/number_unique_strains_at_locus[u]
		Ve[u] = estGeneVar

	# calculate t-like test stat! 
	# From Wetmore et al., t = normGeneFitness/sqrt(sigma^2 + max(Ve,Vn))
	# sigma is a small constant to represent uncertainty in normalization for small fitness values. Set to 0.1
	sigma = 0.1
	tStat_abs = []
	for u in range(0,len(normGeneFitness)):
		max_variance = max(Ve[u], Vn[u])
		tStat_abs1 = np.absolute(normGeneFitness[u]/(np.sqrt((sigma**2) + max_variance)))
		tStat_abs.append(tStat_abs1)

	###############################################################################
	#### write list of ALL analyzed genes with tStat_abs and normGeneFit value ####
	###############################################################################
	structuredArr = np.transpose(np.array([(Loci_Labels), (normGeneFitness), (tStat_abs)]))
	np.savetxt((NoLess30_Gene_Sums_Table.columns[i]+'_allAnalyzedGenes.csv'), structuredArr, delimiter=',', fmt='%s', header='geneName,normGeneFit,tStat_abs', comments='')

